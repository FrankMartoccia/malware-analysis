package org.cocos2dx.lib;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Rect;
import android.graphics.Typeface;
import android.text.TextPaint;
import android.text.TextUtils;
import android.util.Log;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.LinkedList;
/* loaded from: classes.dex */
public class Cocos2dxBitmap {
    private static final int HORIZONTALALIGN_CENTER = 3;
    private static final int HORIZONTALALIGN_LEFT = 1;
    private static final int HORIZONTALALIGN_RIGHT = 2;
    private static final int VERTICALALIGN_BOTTOM = 2;
    private static final int VERTICALALIGN_CENTER = 3;
    private static final int VERTICALALIGN_TOP = 1;
    private static Context sContext;

    private static native void nativeInitBitmapDC(int i, int i2, byte[] bArr);

    public static void setContext(Context context) {
        sContext = context;
    }

    public static void createTextBitmap(String string, String fontName, int fontSize, int alignment, int width, int height) {
        createTextBitmapShadowStroke(string, fontName, fontSize, 255, 255, 255, 255, alignment, width, height, false, 0.0f, 0.0f, 0.0f, 0.0f, false, 255, 255, 255, 255, 0.0f);
    }

    public static boolean createTextBitmapShadowStroke(String string, String fontName, int fontSize, int fontTintR, int fontTintG, int fontTintB, int fontTintA, int alignment, int width, int height, boolean shadow, float shadowDX, float shadowDY, float shadowBlur, float shadowOpacity, boolean stroke, int strokeR, int strokeG, int strokeB, int strokeA, float strokeSize) {
        int bitmapTotalHeight;
        int horizontalAlignment = alignment & 15;
        int verticalAlignment = (alignment >> 4) & 15;
        String string2 = refactorString(string);
        Paint paint = newPaint(fontName, fontSize, horizontalAlignment);
        if (width != 0) {
            int firstWordWidth = (int) Math.ceil(paint.measureText(string2, 0, 1));
            if (firstWordWidth > width) {
                Log.w("createTextBitmapShadowStroke warning:", "the input width is less than the width of the pString's first word\n");
                return false;
            }
        }
        paint.setARGB(fontTintA, fontTintR, fontTintG, fontTintB);
        TextProperty textProperty = computeTextProperty(string2, width, height, paint);
        if (height == 0) {
            bitmapTotalHeight = textProperty.mTotalHeight;
        } else {
            bitmapTotalHeight = height;
        }
        if (textProperty.mMaxWidth == 0 || bitmapTotalHeight == 0) {
            Log.w("createTextBitmapShadowStroke warning:", "textProperty MaxWidth is 0 or bitMapTotalHeight is 0\n");
            return false;
        }
        Bitmap bitmap = Bitmap.createBitmap(textProperty.mMaxWidth + ((int) 0.0f), ((int) 0.0f) + bitmapTotalHeight, Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(bitmap);
        Paint.FontMetricsInt fontMetricsInt = paint.getFontMetricsInt();
        if (stroke) {
            Paint paintStroke = newPaint(fontName, fontSize, horizontalAlignment);
            paintStroke.setStyle(Paint.Style.STROKE);
            paintStroke.setStrokeWidth(strokeSize);
            paintStroke.setARGB(strokeA, strokeR, strokeG, strokeB);
            int y = computeY(fontMetricsInt, height, textProperty.mTotalHeight, verticalAlignment);
            String[] lines2 = textProperty.mLines;
            for (String line : lines2) {
                int x = computeX(line, textProperty.mMaxWidth, horizontalAlignment);
                canvas.drawText(line, x + 0.0f, y + 0.0f, paintStroke);
                canvas.drawText(line, x + 0.0f, y + 0.0f, paint);
                y += textProperty.mHeightPerLine;
            }
        } else {
            int y2 = computeY(fontMetricsInt, height, textProperty.mTotalHeight, verticalAlignment);
            String[] lines = textProperty.mLines;
            for (String line2 : lines) {
                canvas.drawText(line2, computeX(line2, textProperty.mMaxWidth, horizontalAlignment) + 0.0f, y2 + 0.0f, paint);
                y2 += textProperty.mHeightPerLine;
            }
        }
        initNativeObject(bitmap);
        return true;
    }

    private static Paint newPaint(String fontName, int fontSize, int horizontalAlignment) {
        Paint paint = new Paint();
        paint.setColor(-1);
        paint.setTextSize(fontSize);
        paint.setAntiAlias(true);
        if (fontName.endsWith(".ttf")) {
            try {
                Typeface typeFace = Cocos2dxTypefaces.get(sContext, fontName);
                paint.setTypeface(typeFace);
            } catch (Exception e) {
                Log.e("Cocos2dxBitmap", "error to create ttf type face: " + fontName);
                paint.setTypeface(Typeface.create(fontName, 0));
            }
        } else {
            paint.setTypeface(Typeface.create(fontName, 0));
        }
        switch (horizontalAlignment) {
            case 2:
                paint.setTextAlign(Paint.Align.RIGHT);
                break;
            case 3:
                paint.setTextAlign(Paint.Align.CENTER);
                break;
            default:
                paint.setTextAlign(Paint.Align.LEFT);
                break;
        }
        return paint;
    }

    private static TextProperty computeTextProperty(String string, int width, int height, Paint paint) {
        Paint.FontMetricsInt fm = paint.getFontMetricsInt();
        int h = (int) Math.ceil(fm.bottom - fm.top);
        int maxContentWidth = 0;
        String[] lines = splitString(string, width, height, paint);
        if (width != 0) {
            maxContentWidth = width;
        } else {
            for (String line : lines) {
                int temp = (int) Math.ceil(paint.measureText(line, 0, line.length()));
                if (temp > maxContentWidth) {
                    maxContentWidth = temp;
                }
            }
        }
        return new TextProperty(maxContentWidth, h, lines);
    }

    private static int computeX(String text, int maxWidth, int horizontalAlignment) {
        switch (horizontalAlignment) {
            case 2:
                return maxWidth;
            case 3:
                int ret = maxWidth / 2;
                return ret;
            default:
                return 0;
        }
    }

    private static int computeY(Paint.FontMetricsInt fontMetricsInt, int constrainHeight, int totalHeight, int verticalAlignment) {
        int y = -fontMetricsInt.top;
        if (constrainHeight <= totalHeight) {
            return y;
        }
        switch (verticalAlignment) {
            case 1:
                return -fontMetricsInt.top;
            case 2:
                return (-fontMetricsInt.top) + (constrainHeight - totalHeight);
            case 3:
                return (-fontMetricsInt.top) + ((constrainHeight - totalHeight) / 2);
            default:
                return y;
        }
    }

    private static String[] splitString(String string, int maxWidth, int maxHeight, Paint paint) {
        String[] lines = string.split("\\n");
        Paint.FontMetricsInt fm = paint.getFontMetricsInt();
        int heightPerLine = (int) Math.ceil(fm.bottom - fm.top);
        int maxLines = maxHeight / heightPerLine;
        if (maxWidth != 0) {
            LinkedList<String> strList = new LinkedList<>();
            for (String line : lines) {
                int lineWidth = (int) Math.ceil(paint.measureText(line));
                if (lineWidth > maxWidth) {
                    strList.addAll(divideStringWithMaxWidth(line, maxWidth, paint));
                } else {
                    strList.add(line);
                }
                if (maxLines > 0 && strList.size() >= maxLines) {
                    break;
                }
            }
            if (maxLines > 0 && strList.size() > maxLines) {
                while (strList.size() > maxLines) {
                    strList.removeLast();
                }
            }
            String[] ret = new String[strList.size()];
            strList.toArray(ret);
            return ret;
        } else if (maxHeight == 0 || lines.length <= maxLines) {
            return lines;
        } else {
            LinkedList<String> strList2 = new LinkedList<>();
            for (int i = 0; i < maxLines; i++) {
                strList2.add(lines[i]);
            }
            String[] ret2 = new String[strList2.size()];
            strList2.toArray(ret2);
            return ret2;
        }
    }

    private static LinkedList<String> divideStringWithMaxWidth(String string, int maxWidth, Paint paint) {
        int charLength = string.length();
        int start = 0;
        LinkedList<String> strList = new LinkedList<>();
        int i = 1;
        while (i <= charLength) {
            int tempWidth = (int) Math.ceil(paint.measureText(string, start, i));
            if (tempWidth >= maxWidth) {
                int lastIndexOfSpace = string.substring(0, i).lastIndexOf(" ");
                if (lastIndexOfSpace != -1 && lastIndexOfSpace > start) {
                    strList.add(string.substring(start, lastIndexOfSpace));
                    i = lastIndexOfSpace + 1;
                } else if (tempWidth <= maxWidth || i == start + 1) {
                    strList.add(string.substring(start, i));
                } else {
                    strList.add(string.substring(start, i - 1));
                    i--;
                }
                while (i < charLength && string.charAt(i) == ' ') {
                    i++;
                }
                start = i;
            }
            i++;
        }
        if (start < charLength) {
            strList.add(string.substring(start));
        }
        return strList;
    }

    private static String refactorString(String string) {
        if (string.compareTo("") == 0) {
            return " ";
        }
        StringBuilder strBuilder = new StringBuilder(string);
        int start = 0;
        for (int index = strBuilder.indexOf("\n"); index != -1; index = strBuilder.indexOf("\n", start)) {
            if (index == 0 || strBuilder.charAt(index - 1) == '\n') {
                strBuilder.insert(start, " ");
                start = index + 2;
            } else {
                start = index + 1;
            }
            if (start > strBuilder.length() || index == strBuilder.length()) {
                break;
            }
        }
        return strBuilder.toString();
    }

    private static void initNativeObject(Bitmap bitmap) {
        byte[] pixels = getPixels(bitmap);
        if (pixels != null) {
            nativeInitBitmapDC(bitmap.getWidth(), bitmap.getHeight(), pixels);
        }
    }

    private static byte[] getPixels(Bitmap bitmap) {
        if (bitmap == null) {
            return null;
        }
        byte[] pixels = new byte[bitmap.getWidth() * bitmap.getHeight() * 4];
        ByteBuffer buf = ByteBuffer.wrap(pixels);
        buf.order(ByteOrder.nativeOrder());
        bitmap.copyPixelsToBuffer(buf);
        return pixels;
    }

    private static int getFontSizeAccordingHeight(int height) {
        Paint paint = new Paint();
        Rect bounds = new Rect();
        paint.setTypeface(Typeface.DEFAULT);
        int incr_text_size = 1;
        boolean found_desired_size = false;
        while (!found_desired_size) {
            paint.setTextSize(incr_text_size);
            paint.getTextBounds("SghMNy", 0, "SghMNy".length(), bounds);
            incr_text_size++;
            if (height - bounds.height() <= 2) {
                found_desired_size = true;
            }
            Log.d("font size", "incr size:" + incr_text_size);
        }
        return incr_text_size;
    }

    private static String getStringWithEllipsis(String string, float width, float fontSize) {
        if (TextUtils.isEmpty(string)) {
            return "";
        }
        TextPaint paint = new TextPaint();
        paint.setTypeface(Typeface.DEFAULT);
        paint.setTextSize(fontSize);
        return TextUtils.ellipsize(string, paint, width, TextUtils.TruncateAt.END).toString();
    }

    /* JADX INFO: Access modifiers changed from: private */
    /* loaded from: classes.dex */
    public static class TextProperty {
        private final int mHeightPerLine;
        private final String[] mLines;
        private final int mMaxWidth;
        private final int mTotalHeight;

        TextProperty(int maxWidth, int heightPerLine, String[] lines) {
            this.mMaxWidth = maxWidth;
            this.mHeightPerLine = heightPerLine;
            this.mTotalHeight = lines.length * heightPerLine;
            this.mLines = lines;
        }
    }
}
